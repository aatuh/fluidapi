
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>definition: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pakkasys/fluidapi/endpoint/definition/cloner.go (100.0%)</option>
				
				<option value="file1">github.com/pakkasys/fluidapi/endpoint/definition/toapi.go (100.0%)</option>
				
				<option value="file2">github.com/pakkasys/fluidapi/endpoint/middleware/context.go (100.0%)</option>
				
				<option value="file3">github.com/pakkasys/fluidapi/endpoint/middleware/cors.go (100.0%)</option>
				
				<option value="file4">github.com/pakkasys/fluidapi/endpoint/middleware/inputlogic/errorhandler.go (100.0%)</option>
				
				<option value="file5">github.com/pakkasys/fluidapi/endpoint/middleware/inputlogic/middleware.go (100.0%)</option>
				
				<option value="file6">github.com/pakkasys/fluidapi/endpoint/middleware/panichandler.go (100.0%)</option>
				
				<option value="file7">github.com/pakkasys/fluidapi/endpoint/middleware/requestid.go (100.0%)</option>
				
				<option value="file8">github.com/pakkasys/fluidapi/endpoint/middleware/requestlog.go (100.0%)</option>
				
				<option value="file9">github.com/pakkasys/fluidapi/endpoint/middleware/responsewrapper.go (100.0%)</option>
				
				<option value="file10">github.com/pakkasys/fluidapi/endpoint/middleware/stack.go (100.0%)</option>
				
				<option value="file11">github.com/pakkasys/fluidapi/endpoint/order/order.go (0.0%)</option>
				
				<option value="file12">github.com/pakkasys/fluidapi/endpoint/order/todatabase.go (0.0%)</option>
				
				<option value="file13">github.com/pakkasys/fluidapi/endpoint/order/validate.go (0.0%)</option>
				
				<option value="file14">github.com/pakkasys/fluidapi/endpoint/page/page.go (0.0%)</option>
				
				<option value="file15">github.com/pakkasys/fluidapi/endpoint/runner/inputlogic.go (0.0%)</option>
				
				<option value="file16">github.com/pakkasys/fluidapi/endpoint/runner/inputparser.go (0.0%)</option>
				
				<option value="file17">github.com/pakkasys/fluidapi/endpoint/runner/invoke.go (0.0%)</option>
				
				<option value="file18">github.com/pakkasys/fluidapi/endpoint/runner/service.go (0.0%)</option>
				
				<option value="file19">github.com/pakkasys/fluidapi/endpoint/selector/selector.go (0.0%)</option>
				
				<option value="file20">github.com/pakkasys/fluidapi/endpoint/selector/todatabase.go (0.0%)</option>
				
				<option value="file21">github.com/pakkasys/fluidapi/endpoint/update/todatabase.go (0.0%)</option>
				
				<option value="file22">github.com/pakkasys/fluidapi/endpoint/util/context.go (57.1%)</option>
				
				<option value="file23">github.com/pakkasys/fluidapi/endpoint/util/ipaddress.go (62.5%)</option>
				
				<option value="file24">github.com/pakkasys/fluidapi/endpoint/util/requestwrapper.go (50.0%)</option>
				
				<option value="file25">github.com/pakkasys/fluidapi/endpoint/util/responsewrapper.go (92.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package definition

import "github.com/pakkasys/fluidapi/endpoint/middleware"

// Option is a function that modifies an endpoint definition when it is cloned
type Option func(*EndpointDefinition)

// CloneEndpointDefinition clones an endpoint definition with options
func CloneEndpointDefinition(
        original *EndpointDefinition,
        options ...Option,
) *EndpointDefinition <span class="cov8" title="1">{
        cloned := *original
        for _, option := range options </span><span class="cov8" title="1">{
                option(&amp;cloned)
        }</span>
        <span class="cov8" title="1">return &amp;cloned</span>
}

// WithURL clones an endpoint definition with the provided URL
func WithURL(url string) Option <span class="cov8" title="1">{
        return func(e *EndpointDefinition) </span><span class="cov8" title="1">{
                e.URL = url
        }</span>
}

// WithMethod clones an endpoint definition with the provided HTTP method
func WithMethod(method string) Option <span class="cov8" title="1">{
        return func(e *EndpointDefinition) </span><span class="cov8" title="1">{
                e.Method = method
        }</span>
}

// WithMiddlewareStack clones an endpoint definition with the provided
// middleware stack.
func WithMiddlewareStack(
        stack middleware.Stack,
) Option <span class="cov8" title="1">{
        return func(e *EndpointDefinition) </span><span class="cov8" title="1">{
                e.MiddlewareStack = stack
        }</span>
}

// WithMiddlewareWrappersFunc clones an endpoint definition with the provided
// middleware wrappers
func WithMiddlewareWrappersFunc(
        middlewareWrappersFunc func(
                endpointDefinition *EndpointDefinition,
        ) middleware.Stack,
) Option <span class="cov8" title="1">{
        return func(e *EndpointDefinition) </span><span class="cov8" title="1">{
                e.MiddlewareStack = middlewareWrappersFunc(e)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package definition

import (
        "github.com/pakkasys/fluidapi/core/api"
)

// EndpointDefinitionsToAPIEndpoints converts a list of endpoint definitions to
// a list of API endpoints
//
//   - endpointDefinitions: A list of endpoint definitions to convert
func EndpointDefinitionsToAPIEndpoints(
        endpointDefinitions []EndpointDefinition,
) []api.Endpoint <span class="cov8" title="1">{
        endpoints := []api.Endpoint{}

        for _, endpointDefinition := range endpointDefinitions </span><span class="cov8" title="1">{
                middlewares := []api.Middleware{}
                for _, mw := range endpointDefinition.MiddlewareStack </span><span class="cov8" title="1">{
                        middlewares = append(middlewares, mw.Middleware)
                }</span>

                <span class="cov8" title="1">endpoints = append(
                        endpoints,
                        api.Endpoint{
                                URL:         endpointDefinition.URL,
                                Method:      endpointDefinition.Method,
                                Middlewares: middlewares,
                        },
                )</span>
        }

        <span class="cov8" title="1">return endpoints</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "net/http"

        "github.com/pakkasys/fluidapi/core/api"
        "github.com/pakkasys/fluidapi/endpoint/util"
)

// ContextMiddlewareID is the ID of the context middleware
const ContextMiddlewareID = "context"

// ContextMiddlewareWrapper is the middleware wrapper for the context middleware
func ContextMiddlewareWrapper() *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID:         ContextMiddlewareID,
                Middleware: ContextMiddleware(),
        }
}</span>

// ContextMiddleware is the middleware for the context middleware
func ContextMiddleware() api.Middleware <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r.WithContext(util.NewContext(r.Context())))
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "net/http"
        "slices"
        "strings"

        "github.com/pakkasys/fluidapi/core/api"
)

const (
        CORSMiddlewareID = "cors"

        headerAllowOrigin      = "Access-Control-Allow-Origin"
        headerAllowMethods     = "Access-Control-Allow-Methods"
        headerAllowHeaders     = "Access-Control-Allow-Headers"
        headerAllowCredentials = "Access-Control-Allow-Credentials"

        originHeader = "Origin"
)

var (
        corsAllowHeaders = []string{"Content-Type"}
)

// CORSMiddlewareWrapper creates a new MiddlewareWrapper with the CORSMiddleware
//
//   - allowedOrigins: The list of allowed origins
//   - allowedMethods: The list of allowed methods
//   - allowedHeaders: The list of allowed headers
func CORSMiddlewareWrapper(
        allowedOrigins []string,
        allowedMethods []string,
        allowedHeaders []string,
) *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID: CORSMiddlewareID,
                Middleware: CORSMiddleware(
                        allowedOrigins,
                        allowedMethods,
                        allowedHeaders,
                ),
        }
}</span>

// CORSMiddleware creates a new CORS middleware
//
//   - allowedOrigins: The list of allowed origins
//   - allowedMethods: The list of allowed methods
//   - allowedHeaders: The list of allowed headers
func CORSMiddleware(
        allowedOrigins []string,
        allowedMethods []string,
        allowedHeaders []string,
) api.Middleware <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        origin := r.Header.Get(originHeader)
                        if slices.Contains(allowedOrigins, origin) </span><span class="cov8" title="1">{
                                w.Header().Set(headerAllowOrigin, origin)
                        }</span>

                        <span class="cov8" title="1">w.Header().Set(
                                headerAllowMethods,
                                strings.Join(allowedMethods, ","),
                        )

                        w.Header().Set(
                                headerAllowHeaders,
                                strings.Join(
                                        slices.Concat(corsAllowHeaders, allowedHeaders), ",",
                                ),
                        )

                        w.Header().Set(headerAllowCredentials, "true")

                        next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package inputlogic

import (
        "net/http"

        "github.com/pakkasys/fluidapi/core/api"
)

var InternalServerError = api.NewError[any]("INTERNAL_SERVER_ERROR")

// ErrorHandler handles errors and maps them to appropriate HTTP responses.
type ErrorHandler struct{}

// ExpectedError represents an expected error configuration.
// It defines how to handle specific errors that are anticipated.
type ExpectedError struct {
        ID         string  // The ID of the expected error.
        MaskedID   *string // An optional ID to mask the original error ID in the response.
        Status     int     // The HTTP status code to return for this error.
        PublicData bool    // Whether to include the error data in the response.
}

// Handle processes an error and returns the corresponding HTTP status code and
// API error. It checks if the error is an *api.Error[any] and handles it
// accordingly.
func (e ErrorHandler) Handle(
        handleError error,
        expectedErrors []ExpectedError,
) (int, *api.Error[any]) <span class="cov8" title="1">{
        apiError, ok := handleError.(api.APIError)
        if !ok </span><span class="cov8" title="1">{
                return http.StatusInternalServerError, InternalServerError
        }</span>
        <span class="cov8" title="1">return e.handleAPIError(apiError, expectedErrors)</span>
}

func (e *ErrorHandler) handleAPIError(
        apiError api.APIError,
        expectedErrors []ExpectedError,
) (int, *api.Error[any]) <span class="cov8" title="1">{
        expectedError := e.getExpectedError(apiError, expectedErrors)
        if expectedError == nil </span><span class="cov8" title="1">{
                return http.StatusInternalServerError, InternalServerError
        }</span>
        <span class="cov8" title="1">return expectedError.maskAPIError(apiError)</span>
}

func (e *ErrorHandler) getExpectedError(
        apiError api.APIError,
        expectedErrors []ExpectedError,
) *ExpectedError <span class="cov8" title="1">{
        for i := range expectedErrors </span><span class="cov8" title="1">{
                if apiError.GetID() == expectedErrors[i].ID </span><span class="cov8" title="1">{
                        return &amp;expectedErrors[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (expectedError *ExpectedError) maskAPIError(
        apiError api.APIError,
) (int, *api.Error[any]) <span class="cov8" title="1">{
        var useErrorID string
        if expectedError.MaskedID != nil </span><span class="cov8" title="1">{
                useErrorID = *expectedError.MaskedID
        }</span> else<span class="cov8" title="1"> {
                useErrorID = expectedError.ID
        }</span>

        <span class="cov8" title="1">var useData any
        if expectedError.PublicData </span><span class="cov8" title="1">{
                useData = apiError.GetData()
        }</span> else<span class="cov8" title="1"> {
                useData = nil
        }</span>

        <span class="cov8" title="1">return expectedError.Status, &amp;api.Error[any]{ID: useErrorID, Data: useData}</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package inputlogic

import (
        "fmt"
        "net/http"
        "slices"

        "github.com/pakkasys/fluidapi/core/api"
)

// MiddlewareID is a constant used to identify the middleware within the system.
const MiddlewareID = "inputlogic"

// FieldError represents a field-level validation error
type FieldError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// ValidationErrorData contains a list of field-level validation errors
type ValidationErrorData struct {
        Errors []FieldError `json:"errors"`
}

var ValidationError = api.NewError[ValidationErrorData]("VALIDATION_ERROR")

// Internal server expected errors for validation failures.
var internalExpectedErrors []ExpectedError = []ExpectedError{
        {
                ID:         ValidationError.GetID(),
                Status:     http.StatusBadRequest,
                PublicData: true,
        },
}

// Callback represents the function signature used by the middleware to process
// requests. Input is the type of input to the callback, and Output is the type
// of the output.
type Callback[Input any, Output any] func(
        w http.ResponseWriter,
        r *http.Request,
        i *Input,
) (*Output, error)

// ValidatedInput is an interface that should be implemented by input types that
// can be validated.
type ValidatedInput interface {
        Validate() []FieldError
}

// IObjectPicker represents an interface for picking objects from an HTTP
// request.
type IObjectPicker[T any] interface {
        PickObject(r *http.Request, w http.ResponseWriter, obj T) (*T, error)
}

// ILogger represents an interface for logging messages.
type ILogger interface {
        Trace(message ...any)
        Error(message ...any)
}

// IOutputHandler represents an interface for processing and sending output
// based on the request context.
type IOutputHandler interface {
        ProcessOutput(
                w http.ResponseWriter,
                r *http.Request,
                out any,
                outError error,
                statusCode int,
        ) error
}

// Options represents options that can be configured for the middleware.
// It includes an object picker, output handler, and logging functions.
type Options[Input any] struct {
        // Used to extract the input object from the request.
        ObjectPicker IObjectPicker[Input]
        // Handles output processing.
        OutputHandler IOutputHandler
        // Gets an instance of the logger.
        Logger func(*http.Request) ILogger
}

// MiddlewareWrapper wraps the callback and creates a MiddlewareWrapper
// instance that can be used as a middleware handler.
//
// Input is the type of input to the callback.
// Output is the type of the output to be returned.
func MiddlewareWrapper[Input ValidatedInput, Output any](
        callback Callback[Input, Output],
        inputFactory func() *Input,
        expectedErrors []ExpectedError,
        opts Options[Input],
) *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID: MiddlewareID,
                Middleware: Middleware(
                        callback,
                        inputFactory,
                        expectedErrors,
                        opts.ObjectPicker,
                        opts.OutputHandler,
                        opts.Logger,
                ),
                Inputs: []any{*inputFactory()},
        }
}</span>

// Middleware constructs a new middleware that handles input validation,
// error handling, and request-response management.
//
// Input is the type of input to the callback.
// Output is the type of output expected from the callback.
//
//   - callback: The function that handles the request.
//   - inputFactory: A function that returns a pointer to the input object.
//   - expectedErrors: A list of expected errors that can be handled by the
//     middleware.
//   - objectPicker: An object picker that can be used to extract the input
//     object from the request.
//   - outputHandler: The handler that processes and sends the output to the
//     client.
//   - traceLoggerFn: A function that can be used to log trace messages.
//   - errorLoggerFn: A function that can be used to log error messages.
func Middleware[Input ValidatedInput, Output any](
        callback Callback[Input, Output],
        inputFactory func() *Input,
        expectedErrors []ExpectedError,
        objectPicker IObjectPicker[Input],
        outputHandler IOutputHandler,
        loggerFn func(*http.Request) ILogger,
) api.Middleware <span class="cov8" title="1">{
        if objectPicker == nil </span><span class="cov8" title="1">{
                panic("object picker cannot be nil")</span>
        }
        <span class="cov8" title="1">if outputHandler == nil </span><span class="cov8" title="1">{
                panic("output handler cannot be nil")</span>
        }

        <span class="cov8" title="1">allErrors := slices.Concat(internalExpectedErrors, expectedErrors)

        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        input, err := handleInput(
                                w,
                                r,
                                *inputFactory(),
                                objectPicker,
                                loggerFn,
                        )
                        if err != nil </span><span class="cov8" title="1">{
                                handleError(w, r, err, outputHandler, allErrors, loggerFn)
                                return
                        }</span>

                        <span class="cov8" title="1">out, err := callback(w, r, input)
                        if err != nil </span><span class="cov8" title="1">{
                                handleError(w, r, err, outputHandler, allErrors, loggerFn)
                                return
                        }</span>

                        <span class="cov8" title="1">handleOutput(
                                w,
                                r,
                                out,
                                nil,
                                http.StatusOK,
                                outputHandler,
                                loggerFn,
                        )

                        next.ServeHTTP(w, r)</span>
                })
        }
}

func handleError(
        w http.ResponseWriter,
        r *http.Request,
        handleError error,
        outputHandler IOutputHandler,
        expectedErrors []ExpectedError,
        loggerFn func(*http.Request) ILogger,
) <span class="cov8" title="1">{
        statusCode, outError := ErrorHandler{}.Handle(handleError, expectedErrors)

        if loggerFn != nil </span><span class="cov8" title="1">{
                loggerFn(r).Trace(fmt.Sprintf(
                        "Error handler, status code: %d, callback error: %s, output error: %s",
                        statusCode,
                        handleError,
                        outError,
                ))
        }</span>

        <span class="cov8" title="1">handleOutput(w, r, nil, outError, statusCode, outputHandler, loggerFn)</span>
}

func handleInput[Input ValidatedInput](
        w http.ResponseWriter,
        r *http.Request,
        inputObject Input,
        objectPicker IObjectPicker[Input],
        loggerFn func(*http.Request) ILogger,
) (*Input, error) <span class="cov8" title="1">{
        input, err := objectPicker.PickObject(r, w, inputObject)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if loggerFn != nil </span><span class="cov8" title="1">{
                loggerFn(r).Trace("Picked object", *input)
        }</span>

        <span class="cov8" title="1">validationErrors := (*input).Validate()
        if len(validationErrors) &gt; 0 </span><span class="cov8" title="1">{
                return nil, ValidationError.WithData(ValidationErrorData{
                        Errors: validationErrors,
                })
        }</span>

        <span class="cov8" title="1">return input, nil</span>
}

func handleOutput(
        w http.ResponseWriter,
        r *http.Request,
        output any,
        outputError error,
        statusCode int,
        outputHandler IOutputHandler,
        loggerFn func(*http.Request) ILogger,
) <span class="cov8" title="1">{
        err := outputHandler.ProcessOutput(w, r, output, outputError, statusCode)

        if err != nil </span><span class="cov8" title="1">{
                if loggerFn != nil </span><span class="cov8" title="1">{
                        loggerFn(r).Error(fmt.Sprintf(
                                "Error processing output: %s",
                                err,
                        ))
                }</span>
                <span class="cov8" title="1">w.WriteHeader(http.StatusInternalServerError)
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "bytes"
        "fmt"
        "io"
        "net/http"
        "runtime"

        "github.com/pakkasys/fluidapi/core/api"
)

const (
        PanicHandlerMiddlewareID = "panic_handler"

        maxDumpSize = 1024 * 1024
)

// ResponseWrapper is an interface that wraps an http.ResponseWriter.
type ResponseWrapper interface {
        StatusCode() int
        Body() []byte
        Header() http.Header
}

type requestDumpData struct {
        StatusCode int
        Request    struct {
                URL     string
                Params  string
                Headers map[string][]string
                Body    string
        }
        Response struct {
                Headers map[string][]string
                Body    string
        }
}

type responseData struct {
        StatusCode int
        Headers    map[string][]string
        Body       string
}

type panicData struct {
        Err         any             `json:"err"`
        RequestDump requestDumpData `json:"request_dump"`
        StackTrace  []string        `json:"stack_trace"`
}

// PanicHandlerMiddlewareWrapper creates a new MiddlewareWrapper for
// the Panic Handler middleware. This middleware catches and logs any panics
// during the request lifecycle.
//
//   - loggerFn: A function that logs panic information for the request.
func PanicHandlerMiddlewareWrapper(
        loggerFn func(r *http.Request) func(messages ...any),
) *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID:         PanicHandlerMiddlewareID,
                Middleware: PanicHandlerMiddleware(loggerFn),
        }
}</span>

// PanicHandlerMiddleware constructs a middleware that captures and logs any
// panic events during request handling. It uses the provided panic handler
// logger function to log the details.
//
//   - panicHandlerLoggerFn: A function that logs messages in the event of a panic.
func PanicHandlerMiddleware(
        panicHandlerLoggerFn func(r *http.Request) func(messages ...any),
) api.Middleware <span class="cov8" title="1">{
        if panicHandlerLoggerFn == nil </span><span class="cov8" title="1">{
                panic("panicHandlerLoggerFn cannot be nil")</span>
        }

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if err := recover(); err != nil </span><span class="cov8" title="1">{
                                        handlePanic(w, r, err, panicHandlerLoggerFn)
                                }</span>
                        }()

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

func handlePanic(
        w http.ResponseWriter,
        r *http.Request,
        err any,
        panicHandlerLoggerFn func(r *http.Request) func(messages ...any),
) <span class="cov8" title="1">{
        var rd responseData
        rw := GetResponseWrapper(r)
        if rw != nil </span><span class="cov8" title="1">{
                rd = responseData{
                        StatusCode: rw.StatusCode,
                        Headers:    limitHeaders(rw.Header(), maxDumpSize),
                        Body:       string(rw.Body),
                }
        }</span>

        <span class="cov8" title="1">panicHandlerLoggerFn(r)(
                "Panic",
                panicData{
                        Err:         err,
                        RequestDump: *createRequestDumpData(rd, r),
                        StackTrace:  stackTraceSlice(),
                },
        )

        http.Error(
                w,
                http.StatusText(http.StatusInternalServerError),
                http.StatusInternalServerError,
        )</span>
}

func stackTraceSlice() []string <span class="cov8" title="1">{
        var stackTrace []string
        var skip int

        for </span><span class="cov8" title="1">{
                pc, file, line, ok := runtime.Caller(skip)
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }

                // Get the function name and format entry.
                <span class="cov8" title="1">fn := runtime.FuncForPC(pc)
                entry := fmt.Sprintf("%s:%d %s", file, line, fn.Name())
                stackTrace = append(stackTrace, entry)

                skip++</span>
        }

        <span class="cov8" title="1">return stackTrace</span>
}

func createRequestDumpData(
        rd responseData,
        r *http.Request,
) *requestDumpData <span class="cov8" title="1">{
        requestBody, err := readBodyWithLimit(r.Body, maxDumpSize)
        if err != nil </span><span class="cov8" title="1">{
                requestBody = "Error reading request body"
        }</span>

        <span class="cov8" title="1">return &amp;requestDumpData{
                StatusCode: rd.StatusCode,
                Request: struct {
                        URL     string
                        Params  string
                        Headers map[string][]string
                        Body    string
                }{
                        URL:     r.URL.String(),
                        Params:  limitQueryParameters(r.URL.RawQuery, maxDumpSize),
                        Headers: limitHeaders(r.Header, maxDumpSize),
                        Body:    requestBody,
                },
                Response: struct {
                        Headers map[string][]string
                        Body    string
                }{
                        Headers: limitHeaders(rd.Headers, maxDumpSize),
                        Body:    rd.Body,
                },
        }</span>
}

func readBodyWithLimit(body io.ReadCloser, maxSize int64) (string, error) <span class="cov8" title="1">{
        if body == nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">defer body.Close()

        // Limit the reader to the max size
        limitedReader := io.LimitReader(body, maxSize)

        buf := new(bytes.Buffer)
        _, err := buf.ReadFrom(limitedReader)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Check if the body was truncated
        <span class="cov8" title="1">if buf.Len() == int(maxSize) </span><span class="cov8" title="1">{
                return buf.String() + "... (truncated)", nil
        }</span>

        <span class="cov8" title="1">return buf.String(), nil</span>
}

func limitHeaders(
        headers map[string][]string,
        maxSize int,
) map[string][]string <span class="cov8" title="1">{
        limitedHeaders := make(map[string][]string)
        for key, values := range headers </span><span class="cov8" title="1">{
                var limitedValues []string
                if len(values) == 0 </span><span class="cov8" title="1">{
                        limitedHeaders[key] = values
                        continue</span>
                }
                <span class="cov8" title="1">for _, value := range values </span><span class="cov8" title="1">{
                        if len(value) &gt; maxSize </span><span class="cov8" title="1">{
                                limitedValues = append(
                                        limitedValues,
                                        value[:maxSize]+"... (truncated)",
                                )
                        }</span> else<span class="cov8" title="1"> {
                                limitedValues = append(limitedValues, value)
                        }</span>
                }
                <span class="cov8" title="1">limitedHeaders[key] = limitedValues</span>
        }
        <span class="cov8" title="1">return limitedHeaders</span>
}

func limitQueryParameters(params string, maxSize int) string <span class="cov8" title="1">{
        if len(params) &gt; maxSize </span><span class="cov8" title="1">{
                return params[:maxSize] + "... (truncated)"
        }</span>
        <span class="cov8" title="1">return params</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/pakkasys/fluidapi/core/api"
        "github.com/pakkasys/fluidapi/endpoint/util"
)

const RequestIDMiddlewareID = "request_metadata"

var dataKey = util.NewDataKey()

// RequestMetadata represents metadata information associated with an HTTP
// request.
type RequestMetadata struct {
        TimeStart     time.Time // Time when the request started.
        RequestID     string    // Unique identifier for the request.
        RemoteAddress string    // Remote IP address of the client making the request.
        Protocol      string    // Protocol used in the request (e.g., HTTP/1.1).
        HTTPMethod    string    // HTTP method used for the request (e.g., GET, POST).
        URL           string    // Full URL of the request.
}

// RequestIDMiddlewareWrapper creates a new MiddlewareWrapper for the Request ID
// middleware. This middleware generates a unique ID for each request and stores
// it as metadata in the context.
//
//   - requestIDFn: A function that generates a unique request ID.
func RequestIDMiddlewareWrapper(
        requestIDFn func() string,
) *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID:         RequestIDMiddlewareID,
                Middleware: RequestIDMiddleware(requestIDFn),
        }
}</span>

// RequestIDMiddleware constructs a middleware function that generates request
// metadata and stores it in the request's context. This metadata can be used
// for logging and tracking purposes.
//
//   - requestIDFn: A function that generates a unique request ID.
func RequestIDMiddleware(requestIDFn func() string) api.Middleware <span class="cov8" title="1">{
        if requestIDFn == nil </span><span class="cov8" title="1">{
                panic("requestIDFn cannot be nil")</span>
        }

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        requestMetadata := RequestMetadata{
                                TimeStart:     time.Now().UTC(),
                                RequestID:     requestIDFn(),
                                RemoteAddress: util.RequestIPAddress(r),
                                Protocol:      r.Proto,
                                HTTPMethod:    r.Method,
                                URL:           fmt.Sprintf("%s%s", r.Host, r.URL),
                        }
                        util.SetContextValue(r.Context(), dataKey, &amp;requestMetadata)
                        next.ServeHTTP(w, r)
                }</span>)
        }
}

// GetRequestMetadata retrieves the RequestMetadata from the given context.
// If no metadata is found, it returns nil.
//
//   - ctx: The context from which to retrieve the metadata.
func GetRequestMetadata(ctx context.Context) *RequestMetadata <span class="cov8" title="1">{
        return util.GetContextValue[*RequestMetadata](ctx, dataKey, nil)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "context"
        "net/http"
        "time"

        "github.com/pakkasys/fluidapi/core/api"
)

const RequestLogMiddlewareID = "request_log"

// GetRequestMetadataFunc is a function type used for retrieving RequestMetadata
// from a context.
type GetRequestMetadataFunc func(ctx context.Context) *RequestMetadata

type requestLog struct {
        StartTime     time.Time `json:"start_time"`     // Start time of the request.
        RemoteAddress string    `json:"remote_address"` // Remote IP address of the client making the request.
        Protocol      string    `json:"protocol"`       // Protocol used in the request (e.g., HTTP/1.1).
        HTTPMethod    string    `json:"http_method"`    // HTTP method used for the request.
        URL           string    `json:"url"`            // Full URL of the request.
}

// RequestLogMiddlewareWrapper creates a new MiddlewareWrapper for the
// Request Log middleware. This middleware logs request information.
//
//   - requestLoggerFn: A function that logs messages for the request.
func RequestLogMiddlewareWrapper(
        requestLoggerFn func(r *http.Request) func(messages ...any),
) *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID:         RequestLogMiddlewareID,
                Middleware: RequestLogMiddleware(GetRequestMetadata, requestLoggerFn),
        }
}</span>

// RequestLogMiddleware constructs a middleware that logs information about
// incoming requests. It uses the given request metadata retrieval function and
// the request logger function.
//
//   - getMetadataFn: A function that gets metadata from the request context.
//   - requestLoggerFn: A function that logs messages for the request.
func RequestLogMiddleware(
        getMetadataFn GetRequestMetadataFunc,
        requestLoggerFn func(r *http.Request) func(messages ...any),
) api.Middleware <span class="cov8" title="1">{
        if requestLoggerFn == nil </span><span class="cov8" title="1">{
                panic("requestLoggerFn cannot be nil")</span>
        }

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        logRequest(r, getMetadataFn, requestLoggerFn)
                        next.ServeHTTP(w, r)
                        requestLoggerFn(r)("Request completed")
                }</span>)
        }
}

func logRequest(
        r *http.Request,
        getMetadataFn GetRequestMetadataFunc,
        requestLoggerFn func(r *http.Request) func(messages ...any),
) <span class="cov8" title="1">{
        requestMetadata := getMetadataFn(r.Context())
        if requestMetadata == nil </span><span class="cov8" title="1">{
                requestLoggerFn(r)("Request started", "Request metadata not found")
        }</span> else<span class="cov8" title="1"> {
                requestLoggerFn(r)(
                        "Request started",
                        requestLog{
                                StartTime:     time.Now().UTC(),
                                RemoteAddress: requestMetadata.RemoteAddress,
                                Protocol:      requestMetadata.Protocol,
                                HTTPMethod:    requestMetadata.HTTPMethod,
                                URL:           requestMetadata.URL,
                        },
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "net/http"

        "github.com/pakkasys/fluidapi/core/api"
        "github.com/pakkasys/fluidapi/endpoint/util"
)

const ResponseWrapperMiddlewareID = "response_wrapper"

var (
        responseDataKey = util.NewDataKey()
        requestDataKey  = util.NewDataKey()
)

// ResponseWrapperMiddlewareWrapper creates a new MiddlewareWrapper for the
// Response Wrapper middleware.
func ResponseWrapperMiddlewareWrapper() *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID: ResponseWrapperMiddlewareID,
                Middleware: ResponseWrapperMiddleware(
                        util.NewRequestWrapper,
                        util.NewResponseWrapper,
                ),
        }
}</span>

// ResponseWrapperMiddleware constructs a middleware function that wraps the
// request and response.
//
//   - requestWrapperFn: A function that wraps the HTTP request.
//   - responseWrapperFn: A function that wraps the HTTP response.
func ResponseWrapperMiddleware(
        requestWrapperFn func(*http.Request) (*util.RequestWrapper, error),
        responseWrapperFn func(http.ResponseWriter) *util.ResponseWrapper,
) api.Middleware <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        responseWrapper := util.NewResponseWrapper(w)

                        requestWrapper, err := requestWrapperFn(r)
                        if err != nil </span><span class="cov8" title="1">{
                                http.Error(
                                        w,
                                        http.StatusText(http.StatusInternalServerError),
                                        http.StatusInternalServerError,
                                )
                                return
                        }</span>

                        <span class="cov8" title="1">setRequestWrapper(r, requestWrapper)
                        setResponseWrapper(r, responseWrapper)

                        next.ServeHTTP(responseWrapper, requestWrapper.Request)</span>
                })
        }
}

// GetResponseWrapper retrieves the `ResponseWrapper` from the request context.
//
//   - r: The HTTP request from which to retrieve the `ResponseWrapper`.
func GetResponseWrapper(r *http.Request) *util.ResponseWrapper <span class="cov8" title="1">{
        return util.GetContextValue[*util.ResponseWrapper](
                r.Context(),
                responseDataKey,
                nil,
        )
}</span>

// GetRequestWrapper retrieves the `RequestWrapper` from the request context.
//
//   - r: The HTTP request from which to retrieve the `RequestWrapper`.
func GetRequestWrapper(r *http.Request) *util.RequestWrapper <span class="cov8" title="1">{
        return util.GetContextValue[*util.RequestWrapper](
                r.Context(),
                requestDataKey,
                nil,
        )
}</span>

func setResponseWrapper(r *http.Request, rw *util.ResponseWrapper) <span class="cov8" title="1">{
        util.SetContextValue(r.Context(), responseDataKey, rw)
}</span>

func setRequestWrapper(r *http.Request, rw *util.RequestWrapper) <span class="cov8" title="1">{
        util.SetContextValue(r.Context(), requestDataKey, rw)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import "github.com/pakkasys/fluidapi/core/api"

type Stack []api.MiddlewareWrapper

// InsertAfterID inserts a middleware wrapper after the given ID.
//
//   - id: The ID of the middleware to insert after.
//   - wrapper: The middleware wrapper to insert.
func (s *Stack) InsertAfterID(id string, wrapper api.MiddlewareWrapper) bool <span class="cov8" title="1">{
        for i, mw := range *s </span><span class="cov8" title="1">{
                if mw.ID == id </span><span class="cov8" title="1">{
                        if i == len(*s)-1 </span><span class="cov8" title="1">{
                                *s = append(*s, wrapper)
                        }</span> else<span class="cov8" title="1"> {
                                *s = append(
                                        (*s)[:i+1],
                                        append(
                                                []api.MiddlewareWrapper{wrapper},
                                                (*s)[i+1:]...,
                                        )...,
                                )
                        }</span>
                        <span class="cov8" title="1">return true</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package order

import (
        "fmt"
        "slices"
)

type OrderDirection string

const (
        DIRECTION_ASCENDING       OrderDirection = "ASC"
        DIRECTION_ASCENDING_LONG  OrderDirection = "ASCENDING"
        DIRECTION_DESCENDING      OrderDirection = "DESC"
        DIRECTION_DESCENDING_LONG OrderDirection = "DESCENDING"
)

var Directions []OrderDirection = []OrderDirection{
        DIRECTION_ASCENDING,
        DIRECTION_ASCENDING_LONG,
        DIRECTION_DESCENDING,
        DIRECTION_DESCENDING_LONG,
}

type Order struct {
        Field     string         `json:"field"`
        Direction OrderDirection `json:"direction"`
}

func (s Order) GetField() string <span class="cov0" title="0">{
        return s.Field
}</span>

func Get(field string, direction OrderDirection) *Order <span class="cov0" title="0">{
        if !slices.Contains(Directions, direction) </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invalid order direction: %s", direction))</span>
        }

        <span class="cov0" title="0">return &amp;Order{
                Field:     field,
                Direction: direction,
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package order

import (
        "github.com/pakkasys/fluidapi/database/util"
        "github.com/pakkasys/fluidapi/endpoint/dbfield"
)

var DirectionDatabaseTranslations = map[OrderDirection]util.OrderDirection{
        DIRECTION_ASCENDING:       util.OrderAsc,
        DIRECTION_ASCENDING_LONG:  util.OrderAsc,
        DIRECTION_DESCENDING:      util.OrderDesc,
        DIRECTION_DESCENDING_LONG: util.OrderDesc,
}

func ValidateAndTranslateToDatabaseOrders(
        orders []Order,
        allowedOrderFields []string,
        apiToDatabaseFieldTranslation map[string]dbfield.DBField,
) ([]util.Order, error) <span class="cov0" title="0">{
        newOrders, err := ValidateAndDeduplicateOrders(
                orders,
                allowedOrderFields,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">Orders, err := ToDatabaseOrders(
                newOrders,
                apiToDatabaseFieldTranslation,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return Orders, nil</span>
}

func ToDatabaseOrders(
        orders []Order,
        fieldTranslations map[string]dbfield.DBField,
) ([]util.Order, error) <span class="cov0" title="0">{
        newOrders := []util.Order{}

        for i := range orders </span><span class="cov0" title="0">{
                order := orders[i]

                translatedField := fieldTranslations[order.Field]

                // Translate column
                dbColumn := translatedField.Column
                if dbColumn == "" </span><span class="cov0" title="0">{
                        return nil, InvalidOrderFieldError.WithData(
                                InvalidOrderFieldErrorData{
                                        Field: order.Field,
                                },
                        )
                }</span>
                <span class="cov0" title="0">order.Field = dbColumn

                newOrders = append(
                        newOrders,
                        util.Order{
                                Table:     translatedField.Table,
                                Field:     order.Field,
                                Direction: DirectionDatabaseTranslations[order.Direction],
                        },
                )</span>
        }

        <span class="cov0" title="0">return newOrders, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package order

import (
        "slices"
)

func ValidateAndDeduplicateOrders(
        orders []Order,
        allowedOrderFields []string,
) ([]Order, error) <span class="cov0" title="0">{
        newOrders := []Order{}
        addedFields := make(map[string]bool)

        for i := range orders </span><span class="cov0" title="0">{
                order := orders[i]

                if err := validate(order, allowedOrderFields); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">field := order.GetField()
                if !addedFields[field] </span><span class="cov0" title="0">{
                        newOrders = append(newOrders, order)
                        addedFields[field] = true
                }</span>
        }

        <span class="cov0" title="0">return newOrders, nil</span>
}

func validate(order Order, allowedOrderFields []string) error <span class="cov0" title="0">{
        // Check that the order direction is valid
        if !slices.Contains(Directions, order.Direction) </span><span class="cov0" title="0">{
                return InvalidOrderFieldError.WithData(
                        InvalidOrderFieldErrorData{
                                Field: order.Field,
                        },
                )
        }</span>

        // Check that the order field is allowed
        <span class="cov0" title="0">if !slices.Contains(allowedOrderFields, order.Field) </span><span class="cov0" title="0">{
                return InvalidOrderFieldError.WithData(
                        InvalidOrderFieldErrorData{
                                Field: order.Field,
                        },
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package page

type InputPage struct {
        Offset int `json:"offset" validate:"min=0"`
        Limit  int `json:"limit" validate:"min=0"`
}

func (p *InputPage) Validate(maxLimit int) error <span class="cov0" title="0">{
        if p.Limit &gt; maxLimit </span><span class="cov0" title="0">{
                return MaxPageLimitExceededError.WithData(
                        MaxPageLimitExceededErrorData{
                                MaxLimit: maxLimit,
                        },
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package runner

import (
        "net/http"

        "github.com/pakkasys/fluidapi/core/api"
        "github.com/pakkasys/fluidapi/core/client"
        "github.com/pakkasys/fluidapi/endpoint/definition"
        "github.com/pakkasys/fluidapi/endpoint/middleware"
        "github.com/pakkasys/fluidapi/endpoint/middleware/inputlogic"
)

type InputFactory[T any] func() *T

type InputSpecification[Input any] struct {
        URL          string
        Method       string
        InputFactory InputFactory[Input]
}

type StackBuilder interface {
        Build() middleware.Stack
        MustAddMiddleware(wrapper ...api.MiddlewareWrapper) StackBuilder
}

type StackBuilderFactory func() StackBuilder

type SendFunc[I any, W any] func(
        input *I,
        host string,
) (*client.Response[I, W], error)

type Client[I any, O any, W any] struct {
        URL    string
        Method string
        Send   SendFunc[I, W]
}

type Endpoint[I any, O any, W any] struct {
        Definition *definition.EndpointDefinition
        Client     *Client[I, O, W]
}

func GenericEndpointDefinition[I ValidatedInput, O any, W any](
        specification InputSpecification[I],
        callback inputlogic.Callback[I, O],
        expectedErrors []inputlogic.ExpectedError,
        stackBuilderFactoryFn StackBuilderFactory,
        opts inputlogic.Options[I],
        sendFn SendFunc[I, W],
) *Endpoint[I, O, W] <span class="cov0" title="0">{
        definition := &amp;definition.EndpointDefinition{
                URL:    specification.URL,
                Method: specification.Method,
                MiddlewareStack: stackBuilderFactoryFn().
                        MustAddMiddleware(
                                *inputlogic.MiddlewareWrapper(
                                        callback,
                                        specification.InputFactory,
                                        expectedErrors,
                                        opts,
                                ),
                        ).
                        Build(),
        }

        client := &amp;Client[I, O, W]{
                URL:    specification.URL,
                Method: specification.Method,
                Send:   sendFn,
        }

        return &amp;Endpoint[I, O, W]{
                Definition: definition,
                Client:     client,
        }
}</span>

func GetEndpointDefinition[I ParseableInput[ParsedGetEndpointInput], O any, E any, W any](
        specification InputSpecification[I],
        getEntitiesFn GetServiceFunc[E],
        getCountFn GetCountFunc,
        toOutputFn ToGetEndpointOutput[E, O],
        expectedErrors []inputlogic.ExpectedError,
        stackBuilderFactoryFn StackBuilderFactory,
        opts inputlogic.Options[I],
        sendFn SendFunc[I, W],
) *Endpoint[I, O, W] <span class="cov0" title="0">{
        callback := func(
                writer http.ResponseWriter,
                request *http.Request,
                input *I,
        ) (*O, error) </span><span class="cov0" title="0">{
                return GetInvoke(
                        writer,
                        request,
                        *input,
                        getEntitiesFn,
                        getCountFn,
                        toOutputFn,
                )
        }</span>

        <span class="cov0" title="0">return GenericEndpointDefinition(
                specification,
                callback,
                expectedErrors,
                stackBuilderFactoryFn,
                opts,
                sendFn,
        )</span>
}

func UpdateEndpointDefinition[I ParseableInput[ParsedUpdateEndpointInput], O any, W any](
        specification InputSpecification[I],
        updateEntitiesFn UpdateServiceFunc,
        toOutputFn ToUpdateEndpointOutput[O],
        expectedErrors []inputlogic.ExpectedError,
        stackBuilderFactoryFn StackBuilderFactory,
        opts inputlogic.Options[I],
        sendFn SendFunc[I, W],
) *Endpoint[I, O, W] <span class="cov0" title="0">{
        callback := func(
                writer http.ResponseWriter,
                request *http.Request,
                input *I,
        ) (*O, error) </span><span class="cov0" title="0">{
                return UpdateInvoke[I](
                        writer,
                        request,
                        *input,
                        updateEntitiesFn,
                        toOutputFn,
                )
        }</span>

        <span class="cov0" title="0">return GenericEndpointDefinition(
                specification,
                callback,
                expectedErrors,
                stackBuilderFactoryFn,
                opts,
                sendFn,
        )</span>
}

func DeleteEndpointDefinition[I ParseableInput[ParsedDeleteEndpointInput], O any, W any](
        specification InputSpecification[I],
        deleteEntitiesFn DeleteServiceFunc,
        toOutputFn ToDeleteEndpointOutput[O],
        expectedErrors []inputlogic.ExpectedError,
        stackBuilderFactoryFn StackBuilderFactory,
        opts inputlogic.Options[I],
        sendFn SendFunc[I, W],
) *Endpoint[I, O, W] <span class="cov0" title="0">{
        callback := func(
                writer http.ResponseWriter,
                request *http.Request,
                input *I,
        ) (*O, error) </span><span class="cov0" title="0">{
                return DeleteInvoke[I](
                        writer,
                        request,
                        *input,
                        deleteEntitiesFn,
                        toOutputFn,
                )
        }</span>

        <span class="cov0" title="0">return GenericEndpointDefinition(
                specification,
                callback,
                expectedErrors,
                stackBuilderFactoryFn,
                opts,
                sendFn,
        )</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package runner

import (
        "github.com/pakkasys/fluidapi/database/entity"
        databaseutil "github.com/pakkasys/fluidapi/database/util"
        "github.com/pakkasys/fluidapi/endpoint/dbfield"
        "github.com/pakkasys/fluidapi/endpoint/order"
        "github.com/pakkasys/fluidapi/endpoint/page"
        "github.com/pakkasys/fluidapi/endpoint/selector"
        "github.com/pakkasys/fluidapi/endpoint/update"
)

type APIFields map[string]dbfield.DBField

type ParsedGetEndpointInput struct {
        Orders            []databaseutil.Order
        DatabaseSelectors databaseutil.Selectors
        Page              *page.InputPage
        GetCount          bool
}

type ParsedUpdateEndpointInput struct {
        DatabaseSelectors databaseutil.Selectors
        DatabaseUpdates   []entity.Update
        Upsert            bool
}

type ParsedDeleteEndpointInput struct {
        DatabaseSelectors databaseutil.Selectors
        DeleteOpts        *entity.DeleteOptions
}

func ParseGetEndpointInput(
        apiFields APIFields,
        selectors []selector.Selector,
        orders []order.Order,
        allowedOrderFields []string,
        inputPage *page.InputPage,
        maxPageCount int,
        getCount bool,
) (*ParsedGetEndpointInput, error) <span class="cov0" title="0">{
        dbOrders, err := order.ValidateAndTranslateToDatabaseOrders(
                orders,
                allowedOrderFields,
                apiFields,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if inputPage == nil </span><span class="cov0" title="0">{
                inputPage = &amp;page.InputPage{
                        Offset: 0,
                        Limit:  maxPageCount,
                }
        }</span>
        <span class="cov0" title="0">if err := inputPage.Validate(maxPageCount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dbSelectors, err := selector.ToDBSelectors(selectors, apiFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ParsedGetEndpointInput{
                Orders:            dbOrders,
                DatabaseSelectors: dbSelectors,
                Page:              inputPage,
                GetCount:          getCount,
        }, nil</span>
}

func ParseUpdateEndpointInput(
        apiFields APIFields,
        selectors []selector.Selector,
        updates []update.Update,
        upsert bool,
) (*ParsedUpdateEndpointInput, error) <span class="cov0" title="0">{
        dbSelectors, err := selector.ToDBSelectors(selectors, apiFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(dbSelectors) == 0 </span><span class="cov0" title="0">{
                return nil, selector.NeedAtLeastOneSelectorError
        }</span>

        <span class="cov0" title="0">dbUpdates, err := update.ToDBUpdates(updates, apiFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(dbSelectors) == 0 </span><span class="cov0" title="0">{
                return nil, update.NeedAtLeastOneUpdateError
        }</span>

        <span class="cov0" title="0">return &amp;ParsedUpdateEndpointInput{
                DatabaseSelectors: dbSelectors,
                DatabaseUpdates:   dbUpdates,
                Upsert:            upsert,
        }, nil</span>
}

func ParseDeleteEndpointInput(
        apiFields APIFields,
        selectors []selector.Selector,
        orders []order.Order,
        allowedOrderFields []string,
        limit int,
) (*ParsedDeleteEndpointInput, error) <span class="cov0" title="0">{
        dbSelectors, err := selector.ToDBSelectors(selectors, apiFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(dbSelectors) == 0 </span><span class="cov0" title="0">{
                return nil, selector.NeedAtLeastOneSelectorError
        }</span>

        <span class="cov0" title="0">dbOrders, err := order.ValidateAndTranslateToDatabaseOrders(
                orders,
                allowedOrderFields,
                apiFields,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ParsedDeleteEndpointInput{
                DatabaseSelectors: dbSelectors,
                DeleteOpts: &amp;entity.DeleteOptions{
                        Limit:  limit,
                        Orders: dbOrders,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package runner

import (
        "context"

        "github.com/pakkasys/fluidapi/database/entity"
        "github.com/pakkasys/fluidapi/database/util"
        "github.com/pakkasys/fluidapi/endpoint/middleware/inputlogic"

        "net/http"
)

type ValidatedInput interface {
        Validate() []inputlogic.FieldError
}

type ParseableInput[Output any] interface {
        ValidatedInput
        Parse() (*Output, error)
}

type ToGetEndpointOutput[ServiceOutput any, EndpointOutput any] func(
        froms []ServiceOutput,
        count *int,
) *EndpointOutput

type UpdateServiceFunc func(
        ctx context.Context,
        databaseSelectors []util.Selector,
        databaseUpdates []entity.Update,
) (int64, error)

type ToUpdateEndpointOutput[EndpointOutput any] func(
        count int64,
) *EndpointOutput

type DeleteServiceFunc func(
        ctx context.Context,
        databaseSelectors []util.Selector,
        opts *entity.DeleteOptions,
) (int64, error)

type ToDeleteEndpointOutput[EndpointOutput any] func(
        count int64,
) *EndpointOutput

func GetInvoke[I ParseableInput[ParsedGetEndpointInput], O any, E any](
        writer http.ResponseWriter,
        request *http.Request,
        input I,
        serviceFn GetServiceFunc[E],
        getCountFn GetCountFunc,
        toEndpointOutputFn ToGetEndpointOutput[E, O],
) (*O, error) <span class="cov0" title="0">{
        parsedInput, err := input.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">output, count, err := runGetService(
                request.Context(),
                parsedInput,
                serviceFn,
                getCountFn,
                nil,
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return toEndpointOutputFn(output, &amp;count), nil</span>
}

func UpdateInvoke[I ParseableInput[ParsedUpdateEndpointInput], EndpointOutput any](
        writer http.ResponseWriter,
        request *http.Request,
        input ParseableInput[ParsedUpdateEndpointInput],
        serviceFn UpdateServiceFunc,
        toEndpointOutputFn ToUpdateEndpointOutput[EndpointOutput],
) (*EndpointOutput, error) <span class="cov0" title="0">{
        parsedInput, err := input.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">count, err := serviceFn(
                request.Context(),
                parsedInput.DatabaseSelectors,
                parsedInput.DatabaseUpdates,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return toEndpointOutputFn(count), nil</span>
}

func DeleteInvoke[EndpointInput ParseableInput[ParsedDeleteEndpointInput], EndpointOutput any](
        writer http.ResponseWriter,
        request *http.Request,
        input ParseableInput[ParsedDeleteEndpointInput],
        serviceFn DeleteServiceFunc,
        toEndpointOutputFn ToDeleteEndpointOutput[EndpointOutput],
) (*EndpointOutput, error) <span class="cov0" title="0">{
        parsedInput, err := input.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">count, err := serviceFn(
                request.Context(),
                parsedInput.DatabaseSelectors,
                parsedInput.DeleteOpts,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return toEndpointOutputFn(count), nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package runner

import (
        "context"
        "fmt"

        "github.com/pakkasys/fluidapi/database/entity"
        "github.com/pakkasys/fluidapi/database/util"
)

type GetServiceFunc[Output any] func(
        ctx context.Context,
        opts entity.GetOptions,
) ([]Output, error)

type GetCountFunc func(
        ctx context.Context,
        selectors []util.Selector,
        joins []util.Join,
) (int, error)

func runGetService[Output any](
        ctx context.Context,
        parsedEndpoint *ParsedGetEndpointInput,
        serviceFn GetServiceFunc[Output],
        getCountFn GetCountFunc,
        joins []util.Join,
        projections []util.Projection,
) ([]Output, int, error) <span class="cov0" title="0">{
        if parsedEndpoint.GetCount </span><span class="cov0" title="0">{
                if getCountFn == nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("GetCountFunc is nil")
                }</span>

                <span class="cov0" title="0">count, err := getCountFn(
                        ctx,
                        parsedEndpoint.DatabaseSelectors,
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>

                <span class="cov0" title="0">return nil, count, nil</span>
        } else<span class="cov0" title="0"> {
                if serviceFn == nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("GetServiceFunc is nil")
                }</span>

                <span class="cov0" title="0">entities, err := serviceFn(
                        ctx,
                        entity.GetOptions{
                                Options: entity.Options{
                                        Selectors:   parsedEndpoint.DatabaseSelectors,
                                        Orders:      parsedEndpoint.Orders,
                                        Page:        parsedEndpoint.Page,
                                        Joins:       joins,
                                        Projections: projections,
                                },
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>

                <span class="cov0" title="0">return entities, len(entities), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package selector

import (
        "fmt"

        "github.com/pakkasys/fluidapi/endpoint/predicate"
)

// Selector represents a data selector.
type Selector struct {
        AllowedPredicates []predicate.Predicate
        Field             string
        Predicate         predicate.Predicate
        Value             any
}

// String returns a string representation of the selector.
func (i Selector) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s %v", i.Field, i.Predicate, i.Value)
}</span>

type APISelectors []Selector

// GetByFields returns all selectors with the given fields.
//
//   - fields: the fields to search for
func (i APISelectors) GetByFields(fields ...string) []Selector <span class="cov0" title="0">{
        selectors := APISelectors{}
        for f := range fields </span><span class="cov0" title="0">{
                for j := range i </span><span class="cov0" title="0">{
                        if i[j].Field == fields[f] </span><span class="cov0" title="0">{
                                selectors = append(selectors, i[j])
                        }</span>
                }
        }
        <span class="cov0" title="0">return selectors</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package selector

import (
        "slices"

        "github.com/pakkasys/fluidapi/database/util"
        "github.com/pakkasys/fluidapi/endpoint/dbfield"
        "github.com/pakkasys/fluidapi/endpoint/predicate"
)

func ToDBSelectors(
        selectors []Selector,
        apiToDBFieldMap map[string]dbfield.DBField,
) ([]util.Selector, error) <span class="cov0" title="0">{
        var databaseSelectors []util.Selector

        for i := range selectors </span><span class="cov0" title="0">{
                selector := selectors[i]

                // Validate the input predicate
                if !slices.Contains(
                        selector.AllowedPredicates,
                        selector.Predicate,
                ) </span><span class="cov0" title="0">{
                        return nil, PredicateNotAllowedError.WithData(
                                PredicateNotAllowedErrorData{Predicate: selector.Predicate},
                        )
                }</span>

                // Translate the predicate
                <span class="cov0" title="0">dbPredicate, ok := predicate.
                        APIToDatabasePredicates[selector.Predicate]
                if !ok </span><span class="cov0" title="0">{
                        return nil, InvalidPredicateError.WithData(
                                InvalidPredicateErrorData{Predicate: selector.Predicate},
                        )
                }</span>

                // Translate the field
                <span class="cov0" title="0">dbField, ok := apiToDBFieldMap[selector.Field]
                if !ok </span><span class="cov0" title="0">{
                        return nil, InvalidDatabaseSelectorTranslationError.WithData(
                                InvalidDatabaseSelectorTranslationErrorData{Field: selector.Field},
                        )
                }</span>

                <span class="cov0" title="0">databaseSelectors = append(
                        databaseSelectors,
                        util.Selector{
                                Table:     dbField.Table,
                                Field:     dbField.Column,
                                Predicate: dbPredicate,
                                Value:     selector.Value,
                        },
                )</span>
        }

        <span class="cov0" title="0">return databaseSelectors, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package update

import (
        "github.com/pakkasys/fluidapi/database/entity"
        "github.com/pakkasys/fluidapi/endpoint/dbfield"
)

func ToDBUpdates(
        updates []Update,
        apiToDBFieldMap map[string]dbfield.DBField,
) ([]entity.Update, error) <span class="cov0" title="0">{
        var dbUpdates []entity.Update

        for i := range updates </span><span class="cov0" title="0">{
                matchedUpdate := updates[i]

                // Translate the field
                dbField, ok := apiToDBFieldMap[matchedUpdate.Field]
                if !ok </span><span class="cov0" title="0">{
                        return nil, InvalidDatabaseUpdateTranslationError.WithData(
                                InvalidDatabaseUpdateTranslationErrorData{
                                        Field: matchedUpdate.Field,
                                },
                        )
                }</span>

                <span class="cov0" title="0">dbUpdates = append(
                        dbUpdates,
                        entity.Update{
                                Field: dbField.Column,
                                Value: matchedUpdate.Value,
                        },
                )</span>
        }

        <span class="cov0" title="0">return dbUpdates, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package util

import (
        "context"
        "sync"
)

type DataKey int

var (
        base DataKey = 0
        lock sync.Mutex

        mainDataKey = NewDataKey()
)

type contextData struct {
        data sync.Map
}

// NewDataKey safely increments and returns the next value of base.
func NewDataKey() DataKey <span class="cov8" title="1">{
        lock.Lock()
        defer lock.Unlock()
        base++
        return base
}</span>

// NewContext initializes a new context with an empty contextData map.
func NewContext(fromCtx context.Context) context.Context <span class="cov8" title="1">{
        return context.WithValue(fromCtx, mainDataKey, &amp;contextData{})
}</span>

// IsContextSet checks if the custom context is set in the context.
func IsContextSet(ctx context.Context) bool <span class="cov8" title="1">{
        return HasContextValue(ctx, mainDataKey)
}</span>

// HasContextValue checks if a value exists for the provided key within the
// custom data of the context.
func HasContextValue(ctx context.Context, payloadKey any) bool <span class="cov8" title="1">{
        cd, ok := getContextData(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">_, exists := cd.data.Load(payloadKey)
        return exists</span>
}

// GetContextValue tries to retrieve a value from the custom data of the context
// for a given key.
// If the key exists and the value matches the expected type, it returns the
// value. Otherwise, it returns the provided default value.
func GetContextValue[T any](
        ctx context.Context,
        payloadKey any,
        returnOnNull T,
) T <span class="cov8" title="1">{
        cd, ok := getContextData(ctx)
        if !ok </span><span class="cov8" title="1">{
                return returnOnNull
        }</span>

        <span class="cov8" title="1">value, exists := cd.data.Load(payloadKey)
        if !exists </span><span class="cov8" title="1">{
                return returnOnNull
        }</span>

        <span class="cov8" title="1">typedValue, isType := value.(T)
        if !isType </span><span class="cov0" title="0">{
                return returnOnNull
        }</span>

        <span class="cov8" title="1">return typedValue</span>
}

// MustGetContextValue fetches a value directly from the custom data of the
// context for a given key.
// This function  panic if the key does not exist or if ther is a type mismatch.
func MustGetContextValue[T any](ctx context.Context, payloadKey any) T <span class="cov0" title="0">{
        cd, ok := getContextData(ctx)
        if !ok </span><span class="cov0" title="0">{
                panic("get context value: no custom context set in request")</span>
        }
        <span class="cov0" title="0">value, exists := cd.data.Load(payloadKey)
        if !exists </span><span class="cov0" title="0">{
                panic("get context value: key does not exist")</span>
        }

        <span class="cov0" title="0">typedValue, isType := value.(T)
        if !isType </span><span class="cov0" title="0">{
                panic("get context value: type mismatch")</span>
        }

        <span class="cov0" title="0">return typedValue</span>
}

// SetContextValue sets a value in the custom data of the context for the
// provided key.
func SetContextValue(ctx context.Context, payloadKey any, payload any) <span class="cov8" title="1">{
        cd, ok := getContextData(ctx)
        if !ok </span><span class="cov0" title="0">{
                panic("set context value: no custom context set in request")</span>
        }
        <span class="cov8" title="1">cd.data.Store(payloadKey, payload)</span>
}

// CanSetContextValue checks if the custom data of the context is set.
func CanSetContextValue(ctx context.Context) bool <span class="cov0" title="0">{
        _, ok := getContextData(ctx)
        return ok
}</span>

// ClearContextValue clears a value in the custom data of the context for the
// provided key.
func ClearContextValue(ctx context.Context, payloadKey any) <span class="cov0" title="0">{
        cd, ok := getContextData(ctx)
        if ok </span><span class="cov0" title="0">{
                cd.data.Delete(payloadKey)
        }</span>
}

func getContextData(ctx context.Context) (*contextData, bool) <span class="cov8" title="1">{
        cd, ok := ctx.Value(mainDataKey).(*contextData)
        return cd, ok &amp;&amp; cd != nil
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package util

import (
        "net/http"
        "strings"
)

func RequestIPAddress(request *http.Request) string <span class="cov8" title="1">{
        // Check for the IP in X-Forwarded-For header
        forwarded := request.Header.Get("X-Forwarded-For")
        if forwarded != "" </span><span class="cov0" title="0">{
                // X-Forwarded-For can contain multiple IP addresses; take the first one
                ips := strings.Split(forwarded, ",")
                return strings.TrimSpace(ips[0])
        }</span>

        // Fall back to using RemoteAddr if X-Forwarded-For is not available
        <span class="cov8" title="1">ip := request.RemoteAddr
        // RemoteAddr contains IP:Port, so split by ':' and take the first part
        if colonIndex := strings.LastIndex(ip, ":"); colonIndex != -1 </span><span class="cov8" title="1">{
                return ip[:colonIndex]
        }</span>
        <span class="cov0" title="0">return ip</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package util

import (
        "bytes"
        "io"
        "net/http"
)

// RequestWrapper wraps an http.Request, capturing its information for
// inspection and modification.
type RequestWrapper struct {
        *http.Request        // Embedded *http.Request
        BodyContent   []byte // Captured body
}

// NewRequestWrapper creates a new instance of RequestWrapper and captures the
// body content.
func NewRequestWrapper(r *http.Request) (*RequestWrapper, error) <span class="cov8" title="1">{
        // Capture the body content so that it can be read multiple times
        bodyBytes, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

        return &amp;RequestWrapper{
                Request:     r,
                BodyContent: bodyBytes,
        }, nil</span>
}

// GetBodyContent provides a way to read the captured body.
func (rw *RequestWrapper) GetBodyContent() []byte <span class="cov0" title="0">{
        return rw.BodyContent
}</span>

// GetBody provides a way to read the captured body.
func (rw *RequestWrapper) GetBody() (func() (io.ReadCloser, error), error) <span class="cov0" title="0">{
        return func() (io.ReadCloser, error) </span><span class="cov0" title="0">{
                return io.NopCloser(bytes.NewBuffer(rw.BodyContent)), nil
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package util

import (
        "net/http"
)

// ResponseWrapper wraps an http.ResponseWriter, capturing headers and the
// status code written to it.
type ResponseWrapper struct {
        http.ResponseWriter
        Headers       http.Header
        StatusCode    int
        Body          []byte
        headerWritten bool
}

// NewResponseWrapper creates a new instance of ResponseWrapper.
func NewResponseWrapper(w http.ResponseWriter) *ResponseWrapper <span class="cov8" title="1">{
        return &amp;ResponseWrapper{
                ResponseWriter: w,
                Headers:        make(http.Header),
                StatusCode:     http.StatusOK, // Default status code
                headerWritten:  false,
        }
}</span>

// Header overrides the Header method of the http.ResponseWriter interface.
// It returns the captured headers without modifying the underlying
// ResponseWriter's headers.
func (rw *ResponseWrapper) Header() http.Header <span class="cov8" title="1">{
        return rw.Headers
}</span>

// WriteHeader captures the status code to be written, delaying its execution.
func (rw *ResponseWrapper) WriteHeader(statusCode int) <span class="cov8" title="1">{
        if !rw.headerWritten </span><span class="cov8" title="1">{ // Only write headers once
                rw.StatusCode = statusCode
                // Apply the captured headers to the underlying ResponseWriter.
                for key, values := range rw.Headers </span><span class="cov8" title="1">{
                        for _, value := range values </span><span class="cov8" title="1">{
                                rw.ResponseWriter.Header().Add(key, value)
                        }</span>
                }
                <span class="cov8" title="1">rw.ResponseWriter.WriteHeader(statusCode)
                rw.headerWritten = true</span>
        }
}

// Write writes the response body and ensures headers and status code are written.
func (rw *ResponseWrapper) Write(data []byte) (int, error) <span class="cov8" title="1">{
        // Ensure headers and status code are written before writing the body.
        if !rw.headerWritten </span><span class="cov0" title="0">{
                rw.WriteHeader(rw.StatusCode)
        }</span>

        // Append the data to the response body buffer.
        <span class="cov8" title="1">rw.Body = append(rw.Body, data...)

        // Write the data to the underlying ResponseWriter.
        return rw.ResponseWriter.Write(data)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
