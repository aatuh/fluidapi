
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>middleware: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pakkasys/fluidapi/endpoint/middleware/context.go (100.0%)</option>
				
				<option value="file1">github.com/pakkasys/fluidapi/endpoint/middleware/cors.go (100.0%)</option>
				
				<option value="file2">github.com/pakkasys/fluidapi/endpoint/middleware/panichandler.go (100.0%)</option>
				
				<option value="file3">github.com/pakkasys/fluidapi/endpoint/middleware/requestid.go (11.1%)</option>
				
				<option value="file4">github.com/pakkasys/fluidapi/endpoint/middleware/requestlog.go (100.0%)</option>
				
				<option value="file5">github.com/pakkasys/fluidapi/endpoint/middleware/responsewrapper.go (100.0%)</option>
				
				<option value="file6">github.com/pakkasys/fluidapi/endpoint/middleware/stack.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package middleware

import (
        "net/http"

        "github.com/pakkasys/fluidapi/core/api"
        "github.com/pakkasys/fluidapi/endpoint/util"
)

// ContextMiddlewareID is the ID of the context middleware
const ContextMiddlewareID = "context"

// ContextMiddlewareWrapper is the middleware wrapper for the context middleware
func ContextMiddlewareWrapper() *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID:         ContextMiddlewareID,
                Middleware: ContextMiddleware(),
        }
}</span>

// ContextMiddleware is the middleware for the context middleware
func ContextMiddleware() api.Middleware <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r.WithContext(util.NewContext(r.Context())))
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package middleware

import (
        "net/http"
        "slices"
        "strings"

        "github.com/pakkasys/fluidapi/core/api"
)

const (
        CORSMiddlewareID = "cors"

        headerAllowOrigin      = "Access-Control-Allow-Origin"
        headerAllowMethods     = "Access-Control-Allow-Methods"
        headerAllowHeaders     = "Access-Control-Allow-Headers"
        headerAllowCredentials = "Access-Control-Allow-Credentials"

        originHeader = "Origin"
)

var (
        corsAllowHeaders = []string{"Content-Type"}
)

// CORSMiddlewareWrapper creates a new MiddlewareWrapper with the CORSMiddleware
//
//   - allowedOrigins: The list of allowed origins
//   - allowedMethods: The list of allowed methods
//   - allowedHeaders: The list of allowed headers
func CORSMiddlewareWrapper(
        allowedOrigins []string,
        allowedMethods []string,
        allowedHeaders []string,
) *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID: CORSMiddlewareID,
                Middleware: CORSMiddleware(
                        allowedOrigins,
                        allowedMethods,
                        allowedHeaders,
                ),
        }
}</span>

// CORSMiddleware creates a new CORS middleware
//
//   - allowedOrigins: The list of allowed origins
//   - allowedMethods: The list of allowed methods
//   - allowedHeaders: The list of allowed headers
func CORSMiddleware(
        allowedOrigins []string,
        allowedMethods []string,
        allowedHeaders []string,
) api.Middleware <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        origin := r.Header.Get(originHeader)
                        if slices.Contains(allowedOrigins, origin) </span><span class="cov8" title="1">{
                                w.Header().Set(headerAllowOrigin, origin)
                        }</span>

                        <span class="cov8" title="1">w.Header().Set(
                                headerAllowMethods,
                                strings.Join(allowedMethods, ","),
                        )

                        w.Header().Set(
                                headerAllowHeaders,
                                strings.Join(
                                        slices.Concat(corsAllowHeaders, allowedHeaders), ",",
                                ),
                        )

                        w.Header().Set(headerAllowCredentials, "true")

                        next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "bytes"
        "fmt"
        "io"
        "net/http"
        "runtime"

        "github.com/pakkasys/fluidapi/core/api"
)

const (
        PanicHandlerMiddlewareID = "panic_handler"

        maxDumpSize = 1024 * 1024
)

type ResponseWrapper interface {
        StatusCode() int
        Body() []byte
        Header() http.Header
}

type requestDumpData struct {
        StatusCode int
        Request    struct {
                URL     string
                Params  string
                Headers map[string][]string
                Body    string
        }
        Response struct {
                Headers map[string][]string
                Body    string
        }
}

type responseData struct {
        StatusCode int
        Headers    map[string][]string
        Body       string
}

type panicData struct {
        Err         any             `json:"err"`
        RequestDump requestDumpData `json:"request_dump"`
        StackTrace  []string        `json:"stack_trace"`
}

func PanicHandlerMiddlewareWrapper(
        loggerFn func(r *http.Request) func(messages ...any),
) *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID:         PanicHandlerMiddlewareID,
                Middleware: PanicHandlerMiddleware(loggerFn),
        }
}</span>

func PanicHandlerMiddleware(
        panicHandlerLoggerFn func(r *http.Request) func(messages ...any),
) api.Middleware <span class="cov8" title="1">{
        if panicHandlerLoggerFn == nil </span><span class="cov8" title="1">{
                panic("panicHandlerLoggerFn cannot be nil")</span>
        }

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if err := recover(); err != nil </span><span class="cov8" title="1">{
                                        handlePanic(w, r, err, panicHandlerLoggerFn)
                                }</span>
                        }()

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

func handlePanic(
        w http.ResponseWriter,
        r *http.Request,
        err any,
        panicHandlerLoggerFn func(r *http.Request) func(messages ...any),
) <span class="cov8" title="1">{
        var rd responseData
        rw := GetResponseWrapper(r)
        if rw != nil </span><span class="cov8" title="1">{
                rd = responseData{
                        StatusCode: rw.StatusCode,
                        Headers:    limitHeaders(rw.Header(), maxDumpSize),
                        Body:       string(rw.Body),
                }
        }</span>

        <span class="cov8" title="1">panicHandlerLoggerFn(r)(
                "Panic",
                panicData{
                        Err:         err,
                        RequestDump: *createRequestDumpData(rd, r),
                        StackTrace:  stackTraceSlice(),
                },
        )

        http.Error(
                w,
                http.StatusText(http.StatusInternalServerError),
                http.StatusInternalServerError,
        )</span>
}

func stackTraceSlice() []string <span class="cov8" title="1">{
        var stackTrace []string
        var skip int

        for </span><span class="cov8" title="1">{
                pc, file, line, ok := runtime.Caller(skip)
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }

                // Get the function name and format entry.
                <span class="cov8" title="1">fn := runtime.FuncForPC(pc)
                entry := fmt.Sprintf("%s:%d %s", file, line, fn.Name())
                stackTrace = append(stackTrace, entry)

                skip++</span>
        }

        <span class="cov8" title="1">return stackTrace</span>
}

func createRequestDumpData(
        rd responseData,
        r *http.Request,
) *requestDumpData <span class="cov8" title="1">{
        requestBody, err := readBodyWithLimit(r.Body, maxDumpSize)
        if err != nil </span><span class="cov8" title="1">{
                requestBody = "Error reading request body"
        }</span>

        <span class="cov8" title="1">return &amp;requestDumpData{
                StatusCode: rd.StatusCode,
                Request: struct {
                        URL     string
                        Params  string
                        Headers map[string][]string
                        Body    string
                }{
                        URL:     r.URL.String(),
                        Params:  limitQueryParameters(r.URL.RawQuery, maxDumpSize),
                        Headers: limitHeaders(r.Header, maxDumpSize),
                        Body:    requestBody,
                },
                Response: struct {
                        Headers map[string][]string
                        Body    string
                }{
                        Headers: limitHeaders(rd.Headers, maxDumpSize),
                        Body:    rd.Body,
                },
        }</span>
}

func readBodyWithLimit(body io.ReadCloser, maxSize int64) (string, error) <span class="cov8" title="1">{
        if body == nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">defer body.Close()

        // Limit the reader to the max size
        limitedReader := io.LimitReader(body, maxSize)

        buf := new(bytes.Buffer)
        _, err := buf.ReadFrom(limitedReader)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Check if the body was truncated
        <span class="cov8" title="1">if buf.Len() == int(maxSize) </span><span class="cov8" title="1">{
                return buf.String() + "... (truncated)", nil
        }</span>

        <span class="cov8" title="1">return buf.String(), nil</span>
}

func limitHeaders(
        headers map[string][]string,
        maxSize int,
) map[string][]string <span class="cov8" title="1">{
        limitedHeaders := make(map[string][]string)
        for key, values := range headers </span><span class="cov8" title="1">{
                var limitedValues []string
                if len(values) == 0 </span><span class="cov8" title="1">{
                        limitedHeaders[key] = values
                        continue</span>
                }
                <span class="cov8" title="1">for _, value := range values </span><span class="cov8" title="1">{
                        if len(value) &gt; maxSize </span><span class="cov8" title="1">{
                                limitedValues = append(
                                        limitedValues,
                                        value[:maxSize]+"... (truncated)",
                                )
                        }</span> else<span class="cov8" title="1"> {
                                limitedValues = append(limitedValues, value)
                        }</span>
                }
                <span class="cov8" title="1">limitedHeaders[key] = limitedValues</span>
        }
        <span class="cov8" title="1">return limitedHeaders</span>
}

func limitQueryParameters(params string, maxSize int) string <span class="cov8" title="1">{
        if len(params) &gt; maxSize </span><span class="cov8" title="1">{
                return params[:maxSize] + "... (truncated)"
        }</span>
        <span class="cov8" title="1">return params</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/pakkasys/fluidapi/core/api"
        "github.com/pakkasys/fluidapi/endpoint/util"
)

const RequestIDMiddlewareID = "request_metadata"

var dataKey = util.NewDataKey()

type RequestMetadata struct {
        TimeStart     time.Time
        RequestID     string
        RemoteAddress string
        Protocol      string
        HTTPMethod    string
        URL           string
}

func RequestIDMiddlewareWrapper(
        requestIDFn func() string,
) *api.MiddlewareWrapper <span class="cov0" title="0">{
        return &amp;api.MiddlewareWrapper{
                ID:         RequestIDMiddlewareID,
                Middleware: RequestIDMiddleware(requestIDFn),
        }
}</span>

func RequestIDMiddleware(requestIDFn func() string) api.Middleware <span class="cov0" title="0">{
        if requestIDFn == nil </span><span class="cov0" title="0">{
                panic("requestIDFn cannot be nil")</span>
        }

        <span class="cov0" title="0">return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        requestMetadata := RequestMetadata{
                                TimeStart:     time.Now().UTC(),
                                RequestID:     requestIDFn(),
                                RemoteAddress: util.RequestIPAddress(r),
                                Protocol:      r.Proto,
                                HTTPMethod:    r.Method,
                                URL:           fmt.Sprintf("%s%s", r.Host, r.URL),
                        }
                        util.SetContextValue(
                                r.Context(),
                                dataKey,
                                &amp;requestMetadata,
                        )
                        next.ServeHTTP(w, r)
                }</span>)
        }
}

func GetRequestMetadata(ctx context.Context) *RequestMetadata <span class="cov8" title="1">{
        return util.GetContextValue[*RequestMetadata](
                ctx,
                dataKey,
                nil,
        )
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/pakkasys/fluidapi/core/api"
)

const RequestLogMiddlewareID = "request_log"

type GetRequestMetadataFunc func(ctx context.Context) *RequestMetadata

type requestLog struct {
        StartTime     time.Time `json:"start_time"`
        RemoteAddress string    `json:"remote_address"`
        Protocol      string    `json:"protocol"`
        HTTPMethod    string    `json:"http_method"`
        URL           string    `json:"url"`
}

func RequestLogMiddlewareWrapper(
        requestLoggerFn func(r *http.Request) func(messages ...any),
) *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID:         RequestLogMiddlewareID,
                Middleware: RequestLogMiddleware(GetRequestMetadata, requestLoggerFn),
        }
}</span>

func RequestLogMiddleware(
        getMetadataFn GetRequestMetadataFunc,
        requestLoggerFn func(r *http.Request) func(messages ...any),
) api.Middleware <span class="cov8" title="1">{
        if requestLoggerFn == nil </span><span class="cov8" title="1">{
                panic("requestLoggerFn cannot be nil")</span>
        }

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        logRequest(r, getMetadataFn, requestLoggerFn)

                        next.ServeHTTP(w, r)

                        if requestLoggerFn != nil </span><span class="cov8" title="1">{
                                requestLoggerFn(r)("Request completed")
                        }</span>
                })
        }
}

func logRequest(
        r *http.Request,
        getMetadataFn GetRequestMetadataFunc,
        requestLoggerFn func(r *http.Request) func(messages ...any),
) <span class="cov8" title="1">{
        requestMetadata := getMetadataFn(r.Context())
        fmt.Println("META ", requestMetadata)
        if requestMetadata == nil </span><span class="cov8" title="1">{
                requestLoggerFn(r)("Request started", "Request metadata not found")
        }</span> else<span class="cov8" title="1"> {
                requestLoggerFn(r)(
                        "Request started",
                        requestLog{
                                StartTime:     time.Now().UTC(),
                                RemoteAddress: requestMetadata.RemoteAddress,
                                Protocol:      requestMetadata.Protocol,
                                HTTPMethod:    requestMetadata.HTTPMethod,
                                URL:           requestMetadata.URL,
                        },
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "net/http"

        "github.com/pakkasys/fluidapi/core/api"
        "github.com/pakkasys/fluidapi/endpoint/util"
)

const ResponseWrapperMiddlewareID = "response_wrapper"

var (
        responseDataKey = util.NewDataKey()
        requestDataKey  = util.NewDataKey()
)

func ResponseWrapperMiddlewareWrapper() *api.MiddlewareWrapper <span class="cov8" title="1">{
        return &amp;api.MiddlewareWrapper{
                ID: ResponseWrapperMiddlewareID,
                Middleware: ResponseWrapperMiddleware(
                        util.NewRequestWrapper,
                        util.NewResponseWrapper,
                ),
        }
}</span>

func ResponseWrapperMiddleware(
        requestWrapperFn func(*http.Request) (*util.RequestWrapper, error),
        responseWrapperFn func(http.ResponseWriter) *util.ResponseWrapper,
) api.Middleware <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        responseWrapper := util.NewResponseWrapper(w)

                        requestWrapper, err := requestWrapperFn(r)
                        if err != nil </span><span class="cov8" title="1">{
                                http.Error(
                                        w,
                                        http.StatusText(http.StatusInternalServerError),
                                        http.StatusInternalServerError,
                                )
                                return
                        }</span>

                        <span class="cov8" title="1">setRequestWrapper(r, requestWrapper)
                        setResponseWrapper(r, responseWrapper)

                        next.ServeHTTP(responseWrapper, requestWrapper.Request)</span>
                })
        }
}
func GetResponseWrapper(r *http.Request) *util.ResponseWrapper <span class="cov8" title="1">{
        return util.GetContextValue[*util.ResponseWrapper](
                r.Context(),
                responseDataKey,
                nil,
        )
}</span>

func GetRequestWrapper(r *http.Request) *util.RequestWrapper <span class="cov8" title="1">{
        return util.GetContextValue[*util.RequestWrapper](
                r.Context(),
                requestDataKey,
                nil,
        )
}</span>

func setResponseWrapper(r *http.Request, rw *util.ResponseWrapper) <span class="cov8" title="1">{
        util.SetContextValue(r.Context(), responseDataKey, rw)
}</span>

func setRequestWrapper(r *http.Request, rw *util.RequestWrapper) <span class="cov8" title="1">{
        util.SetContextValue(r.Context(), requestDataKey, rw)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import "github.com/pakkasys/fluidapi/core/api"

type Stack []api.MiddlewareWrapper

// InsertAfterID inserts a middleware wrapper after the given ID.
//
//   - id: The ID of the middleware to insert after.
//   - wrapper: The middleware wrapper to insert.
func (s *Stack) InsertAfterID(id string, wrapper api.MiddlewareWrapper) bool <span class="cov8" title="1">{
        for i, mw := range *s </span><span class="cov8" title="1">{
                if mw.ID == id </span><span class="cov8" title="1">{
                        if i == len(*s)-1 </span><span class="cov8" title="1">{
                                *s = append(*s, wrapper)
                        }</span> else<span class="cov8" title="1"> {
                                *s = append(
                                        (*s)[:i+1],
                                        append(
                                                []api.MiddlewareWrapper{wrapper},
                                                (*s)[i+1:]...,
                                        )...,
                                )
                        }</span>
                        <span class="cov8" title="1">return true</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
