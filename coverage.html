
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>runner: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pakkasys/fluidapi/endpoint/runner/inputlogic.go (100.0%)</option>
				
				<option value="file1">github.com/pakkasys/fluidapi/endpoint/runner/invoke.go (58.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package runner provides utilities for defining and creating HTTP API endpoints, including middleware configuration, client communication, and data parsing.
package runner

import (
        "net/http"

        "github.com/pakkasys/fluidapi/core/api"
        "github.com/pakkasys/fluidapi/core/client"
        "github.com/pakkasys/fluidapi/database/entity"
        databaseutil "github.com/pakkasys/fluidapi/database/util"
        "github.com/pakkasys/fluidapi/endpoint/dbfield"
        "github.com/pakkasys/fluidapi/endpoint/definition"
        "github.com/pakkasys/fluidapi/endpoint/middleware"
        "github.com/pakkasys/fluidapi/endpoint/middleware/inputlogic"
        "github.com/pakkasys/fluidapi/endpoint/order"
        "github.com/pakkasys/fluidapi/endpoint/page"
        "github.com/pakkasys/fluidapi/endpoint/selector"
        "github.com/pakkasys/fluidapi/endpoint/update"
)

// InputFactory is a function type used to create new instances of an input type.
type InputFactory[T any] func() *T

// InputSpecification defines the URL, HTTP method, and input factory function for an endpoint.
type InputSpecification[Input any] struct {
        URL          string              // URL of the endpoint.
        Method       string              // HTTP method for the endpoint (e.g., GET, POST).
        InputFactory InputFactory[Input] // Factory function to create input objects.
}

// StackBuilder is an interface for building middleware stacks for endpoints.
type StackBuilder interface {
        Build() middleware.Stack                                         // Builds and returns the middleware stack.
        MustAddMiddleware(wrapper ...api.MiddlewareWrapper) StackBuilder // Adds middleware wrappers to the stack.
}

// StackBuilderFactory is a function type that creates a new StackBuilder instance.
type StackBuilderFactory func() StackBuilder

// SendFunc is a function type used to send requests from a client.
type SendFunc[I any, W any] func(
        input *I, // The input data to send.
        host string, // The host to send the request to.
) (*client.Response[I, W], error) // Returns a response or an error.

// Client represents an HTTP client used to communicate with an API endpoint.
type Client[I any, O any, W any] struct {
        URL    string         // URL of the API endpoint.
        Method string         // HTTP method to use.
        Send   SendFunc[I, W] // Function to send the request.
}

// Endpoint represents an API endpoint, including its definition and client.
type Endpoint[I any, O any, W any] struct {
        Definition *definition.EndpointDefinition // The definition of the endpoint.
        Client     *Client[I, O, W]               // The client used to interact with the endpoint.
}

// EndpointOption is a function type used to configure an Endpoint.
type EndpointOption[I any, O any, W any] func(*Endpoint[I, O, W])

// WithMiddlewareWrapper configures an endpoint to use a specific middleware wrapper.
//
// Parameters:
//   - middlewareWrapper: The middleware wrapper to apply to the endpoint.
//
// Returns:
//   - An EndpointOption that applies the specified middleware wrapper.
func WithMiddlewareWrapper[I ValidatedInput, O any, W any](
        middlewareWrapper *api.MiddlewareWrapper,
) EndpointOption[I, O, W] <span class="cov8" title="1">{
        return func(endpoint *Endpoint[I, O, W]) </span><span class="cov8" title="1">{
                endpoint.Definition.MiddlewareStack = middleware.Stack{
                        *middlewareWrapper,
                }
        }</span>
}

// GenericEndpointDefinition creates a generic endpoint definition with
// specified options.
//
// Parameters:
//   - specification: The input specification containing URL, method, and input
//     factory.
//   - callback: The callback function to process the endpoint request.
//   - expectedErrors: A list of expected errors to handle.
//   - stackBuilderFactoryFn: A factory function to create a middleware stack
//     builder.
//   - opts: Options for configuring the input logic.
//   - sendFn: Function to send the request.
//   - options: Additional endpoint options to configure.
//
// Returns:
//   - An Endpoint instance.
func GenericEndpointDefinition[I ValidatedInput, O any, W any](
        specification InputSpecification[I],
        callback inputlogic.Callback[I, O],
        expectedErrors []inputlogic.ExpectedError,
        stackBuilderFactoryFn StackBuilderFactory,
        opts inputlogic.Options[I],
        sendFn SendFunc[I, W],
        options ...EndpointOption[I, O, W],
) *Endpoint[I, O, W] <span class="cov8" title="1">{
        middlewareWrapper := inputlogic.MiddlewareWrapper(
                callback,
                specification.InputFactory,
                expectedErrors,
                opts,
        )

        stackBuilder := stackBuilderFactoryFn().
                MustAddMiddleware(*middlewareWrapper)

        definition := &amp;definition.EndpointDefinition{
                URL:             specification.URL,
                Method:          specification.Method,
                MiddlewareStack: stackBuilder.Build(),
        }

        client := &amp;Client[I, O, W]{
                URL:    specification.URL,
                Method: specification.Method,
                Send:   sendFn,
        }

        endpoint := &amp;Endpoint[I, O, W]{
                Definition: definition,
                Client:     client,
        }

        for _, opt := range options </span><span class="cov8" title="1">{
                opt(endpoint)
        }</span>

        <span class="cov8" title="1">return endpoint</span>
}

// GetEndpointDefinition creates an endpoint definition for a GET request.
//
// Parameters:
//   - specification: The input specification for the GET request.
//   - getEntitiesFn: Function to get entities from the database.
//   - getCountFn: Function to get the count of entities.
//   - toOutputFn: Function to convert entities to output format.
//   - expectedErrors: A list of expected errors to handle.
//   - stackBuilderFactoryFn: A factory function to create a middleware stack
//     builder.
//   - opts: Options for configuring the input logic.
//   - sendFn: Function to send the request.
//   - options: Additional endpoint options to configure.
//
// Returns:
//   - An Endpoint instance.
func GetEndpointDefinition[I ParseableInput[ParsedGetEndpointInput], O any, E any, W any](
        specification InputSpecification[I],
        getEntitiesFn GetServiceFunc[E],
        getCountFn GetCountFunc,
        toOutputFn ToGetEndpointOutput[E, O],
        expectedErrors []inputlogic.ExpectedError,
        stackBuilderFactoryFn StackBuilderFactory,
        opts inputlogic.Options[I],
        sendFn SendFunc[I, W],
        options ...EndpointOption[I, O, W],
) *Endpoint[I, O, W] <span class="cov8" title="1">{
        callback := func(
                writer http.ResponseWriter,
                request *http.Request,
                input *I,
        ) (*O, error) </span><span class="cov8" title="1">{
                return GetInvoke(
                        writer,
                        request,
                        *input,
                        getEntitiesFn,
                        getCountFn,
                        toOutputFn,
                )
        }</span>

        <span class="cov8" title="1">return GenericEndpointDefinition(
                specification,
                callback,
                expectedErrors,
                stackBuilderFactoryFn,
                opts,
                sendFn,
                options...,
        )</span>
}

// UpdateEndpointDefinition creates an endpoint definition for an UPDATE request.
//
// Parameters:
//   - specification: The input specification for the UPDATE request.
//   - updateEntitiesFn: Function to update entities in the database.
//   - toOutputFn: Function to convert the update result to output format.
//   - expectedErrors: A list of expected errors to handle.
//   - stackBuilderFactoryFn: A factory function to create a middleware stack
//     builder.
//   - opts: Options for configuring the input logic.
//   - sendFn: Function to send the request.
//   - options: Additional endpoint options to configure.
//
// Returns:
//   - An Endpoint instance.
func UpdateEndpointDefinition[I ParseableInput[ParsedUpdateEndpointInput], O any, W any](
        specification InputSpecification[I],
        updateEntitiesFn UpdateServiceFunc,
        toOutputFn ToUpdateEndpointOutput[O],
        expectedErrors []inputlogic.ExpectedError,
        stackBuilderFactoryFn StackBuilderFactory,
        opts inputlogic.Options[I],
        sendFn SendFunc[I, W],
        options ...EndpointOption[I, O, W],
) *Endpoint[I, O, W] <span class="cov8" title="1">{
        callback := func(
                writer http.ResponseWriter,
                request *http.Request,
                input *I,
        ) (*O, error) </span><span class="cov8" title="1">{
                return UpdateInvoke[I](
                        writer,
                        request,
                        *input,
                        updateEntitiesFn,
                        toOutputFn,
                )
        }</span>

        <span class="cov8" title="1">return GenericEndpointDefinition(
                specification,
                callback,
                expectedErrors,
                stackBuilderFactoryFn,
                opts,
                sendFn,
                options...,
        )</span>
}

// DeleteEndpointDefinition creates an endpoint definition for a DELETE request.
//
// Parameters:
//   - specification: The input specification for the DELETE request.
//   - deleteEntitiesFn: Function that deletes entities from the database.
//   - toOutputFn: Function that converts the deletion result to the desired
//     output format.
//   - expectedErrors: A list of errors that are expected and handled during
//     request processing.
//   - stackBuilderFactoryFn: A factory function used to create a middleware
//     stack builder for the endpoint.
//   - opts: Options to configure the input logic, such as the object picker and
//     output handler.
//   - sendFn: Function used to send the request, typically wrapped to include
//     additional headers or settings.
//   - options: Additional options for configuring the endpoint, such as
//     middleware wrappers.
//
// Returns:
//   - An Endpoint instance configured for DELETE operations.
func DeleteEndpointDefinition[I ParseableInput[ParsedDeleteEndpointInput], O any, W any](
        specification InputSpecification[I],
        deleteEntitiesFn DeleteServiceFunc,
        toOutputFn ToDeleteEndpointOutput[O],
        expectedErrors []inputlogic.ExpectedError,
        stackBuilderFactoryFn StackBuilderFactory,
        opts inputlogic.Options[I],
        sendFn SendFunc[I, W],
        options ...EndpointOption[I, O, W],
) *Endpoint[I, O, W] <span class="cov8" title="1">{
        callback := func(
                writer http.ResponseWriter,
                request *http.Request,
                input *I,
        ) (*O, error) </span><span class="cov8" title="1">{
                return DeleteInvoke[I](
                        writer,
                        request,
                        *input,
                        deleteEntitiesFn,
                        toOutputFn,
                )
        }</span>

        <span class="cov8" title="1">return GenericEndpointDefinition(
                specification,
                callback,
                expectedErrors,
                stackBuilderFactoryFn,
                opts,
                sendFn,
                options...,
        )</span>
}

var NeedAtLeastOneUpdateError = api.NewError[any]("NEED_AT_LEAST_ONE_UPDATE")
var NeedAtLeastOneSelectorError = api.NewError[any]("NEED_AT_LEAST_ONE_SELECTOR")

type APIFields map[string]dbfield.DBField

type ParsedGetEndpointInput struct {
        Orders            []databaseutil.Order
        DatabaseSelectors databaseutil.Selectors
        Page              *page.Page
        GetCount          bool
}

type ParsedUpdateEndpointInput struct {
        DatabaseSelectors databaseutil.Selectors
        DatabaseUpdates   []entity.Update
        Upsert            bool
}

type ParsedDeleteEndpointInput struct {
        DatabaseSelectors databaseutil.Selectors
        DeleteOpts        *entity.DeleteOptions
}

func ParseGetEndpointInput(
        apiFields APIFields,
        selectors []selector.Selector,
        orders []order.Order,
        allowedOrderFields []string,
        inputPage *page.Page,
        maxPageCount int,
        getCount bool,
) (*ParsedGetEndpointInput, error) <span class="cov8" title="1">{
        dbOrders, err := order.ValidateAndTranslateToDBOrders(
                orders,
                allowedOrderFields,
                apiFields,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if inputPage == nil </span><span class="cov8" title="1">{
                inputPage = &amp;page.Page{
                        Offset: 0,
                        Limit:  maxPageCount,
                }
        }</span>
        <span class="cov8" title="1">if err := inputPage.Validate(maxPageCount); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">dbSelectors, err := selector.ToDBSelectors(selectors, apiFields)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ParsedGetEndpointInput{
                Orders:            dbOrders,
                DatabaseSelectors: dbSelectors,
                Page:              inputPage,
                GetCount:          getCount,
        }, nil</span>
}

func ParseUpdateEndpointInput(
        apiFields APIFields,
        selectors []selector.Selector,
        updates []update.Update,
        upsert bool,
) (*ParsedUpdateEndpointInput, error) <span class="cov8" title="1">{
        dbSelectors, err := selector.ToDBSelectors(selectors, apiFields)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(dbSelectors) == 0 </span><span class="cov8" title="1">{
                return nil, NeedAtLeastOneSelectorError
        }</span>

        <span class="cov8" title="1">dbUpdates, err := update.ToDBUpdates(updates, apiFields)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(dbUpdates) == 0 </span><span class="cov8" title="1">{
                return nil, NeedAtLeastOneUpdateError
        }</span>

        <span class="cov8" title="1">return &amp;ParsedUpdateEndpointInput{
                DatabaseSelectors: dbSelectors,
                DatabaseUpdates:   dbUpdates,
                Upsert:            upsert,
        }, nil</span>
}

func ParseDeleteEndpointInput(
        apiFields APIFields,
        selectors []selector.Selector,
        orders []order.Order,
        allowedOrderFields []string,
        limit int,
) (*ParsedDeleteEndpointInput, error) <span class="cov8" title="1">{
        dbSelectors, err := selector.ToDBSelectors(selectors, apiFields)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(dbSelectors) == 0 </span><span class="cov8" title="1">{
                return nil, NeedAtLeastOneSelectorError
        }</span>

        <span class="cov8" title="1">dbOrders, err := order.ValidateAndTranslateToDBOrders(
                orders,
                allowedOrderFields,
                apiFields,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ParsedDeleteEndpointInput{
                DatabaseSelectors: dbSelectors,
                DeleteOpts: &amp;entity.DeleteOptions{
                        Limit:  limit,
                        Orders: dbOrders,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package runner

import (
        "context"
        "fmt"

        "github.com/pakkasys/fluidapi/database/entity"
        "github.com/pakkasys/fluidapi/database/util"
        "github.com/pakkasys/fluidapi/endpoint/middleware/inputlogic"

        "net/http"
)

type ValidatedInput interface {
        Validate() []inputlogic.FieldError
}

type ParseableInput[Output any] interface {
        ValidatedInput
        Parse() (*Output, error)
}

type ToGetEndpointOutput[ServiceOutput any, EndpointOutput any] func(
        froms []ServiceOutput,
        count *int,
) *EndpointOutput

type UpdateServiceFunc func(
        ctx context.Context,
        databaseSelectors []util.Selector,
        databaseUpdates []entity.Update,
) (int64, error)

type ToUpdateEndpointOutput[EndpointOutput any] func(
        count int64,
) *EndpointOutput

type DeleteServiceFunc func(
        ctx context.Context,
        databaseSelectors []util.Selector,
        opts *entity.DeleteOptions,
) (int64, error)

type ToDeleteEndpointOutput[EndpointOutput any] func(
        count int64,
) *EndpointOutput

type GetServiceFunc[Output any] func(
        ctx context.Context,
        opts entity.GetOptions,
) ([]Output, error)

type GetCountFunc func(
        ctx context.Context,
        selectors []util.Selector,
        joins []util.Join,
) (int, error)

func GetInvoke[I ParseableInput[ParsedGetEndpointInput], O any, E any](
        writer http.ResponseWriter,
        request *http.Request,
        input I,
        serviceFn GetServiceFunc[E],
        getCountFn GetCountFunc,
        toEndpointOutputFn ToGetEndpointOutput[E, O],
) (*O, error) <span class="cov8" title="1">{
        parsedInput, err := input.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, count, err := runGetService(
                request.Context(),
                parsedInput,
                serviceFn,
                getCountFn,
                nil,
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return toEndpointOutputFn(output, &amp;count), nil</span>
}

func UpdateInvoke[I ParseableInput[ParsedUpdateEndpointInput], EndpointOutput any](
        writer http.ResponseWriter,
        request *http.Request,
        input ParseableInput[ParsedUpdateEndpointInput],
        serviceFn UpdateServiceFunc,
        toEndpointOutputFn ToUpdateEndpointOutput[EndpointOutput],
) (*EndpointOutput, error) <span class="cov8" title="1">{
        parsedInput, err := input.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">count, err := serviceFn(
                request.Context(),
                parsedInput.DatabaseSelectors,
                parsedInput.DatabaseUpdates,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return toEndpointOutputFn(count), nil</span>
}

func DeleteInvoke[EndpointInput ParseableInput[ParsedDeleteEndpointInput], EndpointOutput any](
        writer http.ResponseWriter,
        request *http.Request,
        input ParseableInput[ParsedDeleteEndpointInput],
        serviceFn DeleteServiceFunc,
        toEndpointOutputFn ToDeleteEndpointOutput[EndpointOutput],
) (*EndpointOutput, error) <span class="cov8" title="1">{
        parsedInput, err := input.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">count, err := serviceFn(
                request.Context(),
                parsedInput.DatabaseSelectors,
                parsedInput.DeleteOpts,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return toEndpointOutputFn(count), nil</span>
}

func runGetService[Output any](
        ctx context.Context,
        parsedEndpoint *ParsedGetEndpointInput,
        serviceFn GetServiceFunc[Output],
        getCountFn GetCountFunc,
        joins []util.Join,
        projections []util.Projection,
) ([]Output, int, error) <span class="cov8" title="1">{
        if parsedEndpoint.GetCount </span><span class="cov0" title="0">{
                if getCountFn == nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("GetCountFunc is nil")
                }</span>

                <span class="cov0" title="0">count, err := getCountFn(
                        ctx,
                        parsedEndpoint.DatabaseSelectors,
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>

                <span class="cov0" title="0">return nil, count, nil</span>
        } else<span class="cov8" title="1"> {
                if serviceFn == nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("GetServiceFunc is nil")
                }</span>

                <span class="cov8" title="1">entities, err := serviceFn(
                        ctx,
                        entity.GetOptions{
                                Options: entity.Options{
                                        Selectors:   parsedEndpoint.DatabaseSelectors,
                                        Orders:      parsedEndpoint.Orders,
                                        Page:        parsedEndpoint.Page,
                                        Joins:       joins,
                                        Projections: projections,
                                },
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>

                <span class="cov8" title="1">return entities, len(entities), nil</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
